from torch.utils.data import Dataset
import cv2
import numpy as np
import torch
import torchvision.transforms as transforms
from PIL import Image


# free form mask (generated by algorithm)
def np_free_form_mask(maxVertex, maxLength, maxBrushWidth, maxAngle, h, w):
    mask = np.zeros((h, w), np.float32)
    numVertex = np.random.randint(2, maxVertex + 1)
    startY = np.random.randint(20, h-20)
    startX = np.random.randint(20, w-20)
    brushWidth = 0
    pre_angle = 0
    for i in range(numVertex):
        angle = np.random.randint(maxAngle + 1)
        angle = (angle / 360.0 * 2 * np.pi + pre_angle)/2
        
        if i % 2 == 0:
            angle = 2 * np.pi - angle
        length = np.random.randint(1, maxLength + 1)
        brushWidth = np.random.randint(8, maxBrushWidth + 1) // 2 * 2
        nextY = startY + length * np.cos(angle)
        nextX = startX + length * np.sin(angle)

        nextY = np.maximum(np.minimum(nextY, h - 40), 40).astype(np.int)
        nextX = np.maximum(np.minimum(nextX, w - 40), 40).astype(np.int)

        cv2.line(mask, (startY, startX), (nextY, nextX), 1, brushWidth)

        startY, startX = nextY, nextX
        pre_angle = angle
    return mask


###########################################
#            OESDataset
###########################################
class OESDataset(Dataset):
    def __init__(self, dataset, img_size=(256, 256), aug_data=None, normalize=True):
        """
        Args:
            dataset: dataset to be corrupted via different operations (inpainting, blending...)
        """
        # original torchvison dataset
        self.img_files = dataset.img_files
        self.len = dataset.len
        self.h, self.w = img_size
        self.img_size = img_size

        if normalize:
            normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                                std=[0.229, 0.224, 0.225])
            self.transform = transforms.Compose([transforms.ToTensor(), normalize])
        else:
            self.transform = transforms.Compose([transforms.ToTensor()])

        # aug dataset (default imagenet)
        if aug_data is None:
            try:
                from datasets.imagenet import ILSVRC
                data_path = "/home/jie/Datasets/ILSVRC2012"
                meta_path = "/home/jie/Datasets/ILSVRC2012/ILSVRC2012_devkit_t12/data/meta.mat"
                self.aug_data = ILSVRC(ilsvrc_data_path=data_path, meta_path=meta_path, val=False)
            except:
                print("ILSVRC2012 not Found! Traning witout Self-Feature Enhancement with external Datasets")
                self.aug_data = None
        else:
            self.aug_data = aug_data

    def __getitem__(self, index):
        # read image (to be corrupted)
        img = cv2.imread(self.img_files[index])
        img = cv2.resize(img, (self.w, self.h))
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)    # as RGB image

        img_normal = img.copy()
        
        # OE
        if self.aug_data is not None:
            OE_mode = np.random.randint(0, 5)    # OE mode
        else:
            OE_mode = np.random.randint(0, 4)    # OE mode

        # generate random anomaly mask
        mask = self.generate_mask()    # [0, 1]

        # inpainting with opencv
        if OE_mode == 1:
            inpaint_mask = (mask*255).astype(np.uint8)
            img = cv2.inpaint(img, inpaint_mask, 5, cv2.INPAINT_TELEA)

        # constant fill (filling with sampled pixel from the orginal image)
        if OE_mode == 2:
            indx, indy = np.where(mask > 0 if np.random.rand() > 0.4 else mask == 0)    # prefer to sample pixel in anoamly region 
            index = np.random.randint(0, len(indx))
            img_to_inpaint = np.ones_like(img) * img[indx[index],indy[index]]
            # alpha = 0.1 * np.random.randint(1,5)    # blending coefficient
            alpha_min = 0.1
            alpha_range = 0.4
            alpha = alpha_min + np.random.rand() * alpha_range
            img_to_inpaint = cv2.addWeighted(img, alpha, img_to_inpaint, 1-alpha, 0)
            img = img_to_inpaint*mask[:,:,np.newaxis] + img*(1-mask[:,:,np.newaxis])

        # noise fill
        if OE_mode == 3:
            img_to_inpaint = (np.random.rand(*img.shape)*255).astype(np.int16)
            img_to_inpaint = img_to_inpaint.astype(np.uint8)
            alpha_min = 0.3
            alpha_range = 0.5
            alpha = alpha_min + np.random.rand() * alpha_range
            img_to_inpaint = cv2.addWeighted(img, alpha, img_to_inpaint, 1-alpha, 0)
            img = img_to_inpaint*mask[:,:,np.newaxis] + img*(1-mask[:,:,np.newaxis])

        # a-blending
        if OE_mode == 4:
            # generate a image for blending (here from imagenet)
            img_to_blend = self.generate_image_to_blend()
            alpha_min = 0.3
            alpha_range = 0.5
            alpha = alpha_min + np.random.rand() * alpha_range
            img_to_blend = cv2.addWeighted(img, alpha, img_to_blend, 1-alpha, 0)
            img = img_to_blend*mask[:,:,np.newaxis] + img*(1-mask[:,:,np.newaxis])
        
        img_abnormal = Image.fromarray(img.astype(np.uint8))    # as PIL image
        img_abnormal = self.transform(img_abnormal)

        img_normal = Image.fromarray(img_normal.astype(np.uint8))    # as PIL image
        img_normal = self.transform(img_normal)

        # TODO: zero input in anomaly region
        if OE_mode == 0:
            img_abnormal = img_abnormal - img_abnormal * torch.from_numpy(mask)

        return img_normal, img_abnormal, mask.astype(np.float32)

    def __len__(self):
        return self.len

    def generate_mask(self):
        max_anomaly_regions = 3    # possible max number of anomaly regions
        parts = np.random.randint(1, max_anomaly_regions+1)

        mask = 0
        for part in range(parts):
            # brush params
            maxBrushWidth = np.random.randint(8, 48)
            maxLength = 32
            maxVertex = np.random.randint(12, 16)
            
            temp_mask = np_free_form_mask(maxVertex, maxLength, maxBrushWidth, maxAngle=180, h=self.h, w=self.w)
            mask = np.logical_or(mask, temp_mask)
        return mask
    
    def generate_image_to_blend(self):

        idx = int(np.random.rand() * len(self.aug_data))
        img_to_blend = cv2.imread(self.aug_data.samples[idx][0])
        img_to_blend = cv2.resize(img_to_blend, (self.w, self.h))
        img_to_blend = cv2.cvtColor(img_to_blend, cv2.COLOR_BGR2RGB)
        return img_to_blend

